---
title: Efficient Settings with Prisma and TypeScript
shortTitle: Settings
id: prisma-settings
description: A look at how to use TypeScript generics to make settings more efficient with Prisma.
pubDate: Dec 24 2024
image: 
  img: './images/photo-1611914974124-466c45d4c7a5.avif'
  alt: An image of a prism
  aspect: 2
related:
  - contour
tags:
  - TypeScript
  - Prisma
---

In multiple projects, I have needed to implement settings that are stored in a `sqlite` database and accessed via [Prisma](https://www.prisma.io/). This is quite easy, as long as type-safety isn't a consideration.

Take this fairly simple table schema:

```prisma
model Settings {
  setting String @id
  value   String

  @@map("settings")
}
```

In this example, settings are stored as a key-value pair, with the `value` always being a string. This is fairly efficient, and means that settings can be added at any time _without_ updating the database schema. This simplicity is great, but it does have some drawbacks:

- **No type safety**: The `value` column is always a string in the database. Without an additional layer in-between this an our application, numbers, booleans, and enums are not possible.
- **Undefined default values**: If the database may not have the requested setting stored if it has never been assigned.
- **TypeScript doesn't know what is going on**: The `prisma` client has no idea what the settings are, or what they should be.

We can do better by adding a system to manage our settings that is both efficient and type-safe, and ultimately uses the same simple `prisma` schema from above.

## Generics

TypeScript, like many other languages, supports generics, which allow for assigning type at 'runtime'. Since TypeScript is just layered on top of JavaScript, 'runtime' isn't really the right word for when the types are assigned, but it's close enough. 

```typescript
// A basic generic type definition
type MyGeneric<T> = {
  value: T;
}

const myNumber: MyGeneric<number> = {
  value: 5
}

const myString: MyGeneric<string> = {
  value: 'my string'
}
```

When using these variables, TypeScript (and therefore the IDE) will know that `myString.value` is a string, and `myNumber.value` is a number. Though a very simple example, this allows for some pretty complex type definitions that can stack in interesting ways.


## Application Considerations

### Accessing Settings

In our simple `prisma` schema, settings can be easily fetched in parallel, either by individual name or by a grouping, by using `prisma` operations directly:

```typescript
// Multiple settings fetched at the same time by name:
const myParallelSettings = await prisma.settings.findMany({
  where: {
    setting: {
      in: ['setting1', 'setting2', 'setting3']
    }
  }
});

// Multiple settings fetched at the same time by grouping:
const myGroupedSettings = await prisma.settings.findMany({
  where: {
    setting: {
      startsWith: 'my.settings.group'
    }
  }
});

```

This ease of use and efficiency is something I wanted to preserve in my settings system.

### Default Values

When new settings are implemented for use with new application logic, deployed database instances will not have these settings stored. As a result, the application must have default values handy. If a setting is not found in the database, the default value will be used and stored back to the database for next use.

## Usage

### Load by Group/Set

```typescript
// The IDE knows which setting sets are available
const entrySettings = await settings.getSet('entry');
```

### Load by Name

```typescript
// The IDE knows which individual settings are available
const entrySettings = await settings.get('setting1');
```

### Load Many by Name

```typescript
// The IDE knows which individual settings are available
const entrySettings = await settings.getMany('setting1', 'setting2', 'setting3');
```

### Assignment

```typescript
// The IDE knows which individual settings are available,
// and what the assignment types should be for each
await settings.set('setting1', 'new value');
await settings.set('setting2', false);
await settings.set('setting3', 42);
```


## Full Implementation

`Prisma` Schema:
```prisma
model Settings {
  setting String @id
  value   String

  @@map("settings")
}
```

`settings.ts`:
```typescript
import prisma from '$lib/server/prisma';
import type { Prisma } from '@prisma/client';

// Enum Definition
export enum MyEnum {
	NOT_STARTED = 'NOT_STARTED',
	LINK_ENTERED = 'LINK_ENTERED',
	LINK_CONFIRMED = 'LINK_CONFIRMED',
}

// -------------------------------------------------------------------------------------------------
// Setting Configuration
// -------------------------------------------------------------------------------------------------

// Default Values
export const DefaultValues = {
  'general.string': 'default string',
	'general.integer': 42,
  'general.float': 3.14159,
	'general.boolean': true,
	'general.enum': MyEnum.NOT_STARTED,
};
export type TypeName = keyof typeof DefaultValues;

// Setting Type Definitions
export type ObjectType<T extends TypeName> = 
	T extends 'general.string' ? string :
	T extends 'general.integer' ? number :
  T extends 'general.float' ? number :
  T extends 'general.boolean' ? boolean :
	T extends 'general.enum' ? MyEnum :
	string;

// -------------------------------------------------------------------------------------------------
// Setting Functions
// -------------------------------------------------------------------------------------------------

export type SettingPayload = Prisma.SettingsGetPayload<{}>;

/**
 * Get a setting from the DB
 * @param setting the setting to get
 * @returns the setting
 */
export const get = async <T extends TypeName>(setting: T, settingVal?: SettingPayload | null): Promise<ObjectType<T>> => {
	// Make sure the setting can exist
	if (!(setting in DefaultValues)) throw Error(`Unknown setting: ${setting}`);

	// Pull the setting from the DB if required
	if (settingVal === undefined)
		settingVal = await prisma.settings.findUnique({ where: { setting } });

	// Check if it exists
	if (settingVal !== undefined && settingVal !== null) {
		// It does. Fetch, cast and return.
		switch (setting) {
			// Boolean Conversion ------------------------------------------------------------------------
			case 'general.boolean':
				return (settingVal.value === 'true' ? true : false) as ObjectType<T>;

			// Integer Conversion ------------------------------------------------------------------------
			case 'general.integer':
				return parseInt(settingVal.value) as ObjectType<T>;

			// Float Conversion --------------------------------------------------------------------------
			case 'general.float':
				return parseFloat(settingVal.value) as ObjectType<T>;

			// String Conversion -------------------------------------------------------------------------
			case 'general.string':
				return settingVal.value as ObjectType<T>;

			// Enum Conversion ---------------------------------------------------------------------------
			case 'general.enum':
				return settingVal.value as ObjectType<T>;

			// Unknown -----------------------------------------------------------------------------------
			default:
				throw Error(`Unknown setting: ${setting}`);
		}
	} else {
		// Assign the default to the DB and return the default value.
		const defaultVal = DefaultValues[setting] as unknown as ObjectType<T>;

		// Write the default value to the DB
		await prisma.settings.create({ data: { setting, value: defaultVal.toString() } });

		// Return the default value
		return defaultVal;
	}
};

// Generate two helpers types that will allow us to select based on the settings
export type SettingsSet<T extends TypeName, Prefix extends string> = T extends `${Prefix}.${infer Rest}` ? T : never;
type SettingsPrefix<T extends TypeName, Prefix extends string> = T extends `${Prefix}.${infer Rest}` ? Prefix : never;

/**
 * Get a set of settings, as long as they match a certain prefix
 * @param prefix the prefix to match
 * @returns an object with the settings
 */
export const getSet = async <Prefix extends string>(prefix: SettingsPrefix<TypeName, Prefix>): Promise<{ [K in SettingsSet<TypeName, Prefix>]: ObjectType<K> }> => {
	// Get the possible settings keys based on the prefix
	const keys = (Object.keys(DefaultValues) as TypeName[]).filter((key) => key.startsWith(prefix)) as SettingsSet<TypeName, Prefix>[];
	// Initialize a resulting settings object, typed to only include the settings we will return
	const settings = {} as { [K in (typeof keys)[number]]: ObjectType<K> };

	// Get the settings from the DB
	const manySettings = await prisma.settings.findMany({where: { setting: { startsWith: prefix } } });

	// Loop through the possible settings
	for (const key of keys) {
		// If the setting does not exist, error. Since we generated the keys array right above this, we should never get this error.
		if (!(key in DefaultValues)) throw Error(`Unknown setting: ${key}`);
		// Find the setting from the DB, if it is in there
		const keyIdx = manySettings.findIndex((s) => s.setting === key);
		// If it is, pass it to the basic `get` function so it can be properly cast
		if (keyIdx !== -1) settings[key] = (await get(key, manySettings[keyIdx])) as never;
		// If not, return a default value
		else settings[key] = DefaultValues[key] as never;
	}

	// Return the settings
	return settings;
};

// Generate a helper type that will allow us to select based on settings
type FilterSettingsMany<T extends TypeName, Search extends string> = T extends `${Search}` ? T : never;

/**
 * Get many fully-qualified settings
 * @param settings the settings to get
 * @returns an object with the settings
 */
export const getMany = async <T extends TypeName>(...settings: T[]): Promise<{ [K in FilterSettingsMany<TypeName, T>]: ObjectType<K> }> => {
	// Get the possible settings keys based on the inputs. This protects against uncaught typescript errors
	const keys: TypeName[] = [];
	for (const setting of settings) if (setting in DefaultValues) keys.push(setting);
	// Initialize a resulting settings object, typed to only include the settings we will return
	const results = {} as { [K in (typeof keys)[number]]: ObjectType<K> };

	// Get the settings from the DB
	const manySettings = await prisma.settings.findMany({ where: { setting: { in: settings } } });

	// Loop through the requested settings
	for (const key of keys) {
		// If the setting does not exist, error.
		if (!(key in DefaultValues)) throw Error(`Unknown setting: ${key}`);
		// Find the setting from the DB, if it is in there
		const keyIdx = manySettings.findIndex((s) => s.setting === key);
		// If it is, pass it to the basic `get` function so it can be properly cast
		if (keyIdx !== -1) results[key] = (await get(key, manySettings[keyIdx])) as never;
		// If not, return a default value
		else results[key] = DefaultValues[key] as never;
	}

	// Return the settings
	return results;
};

/**
 * Set a setting in the database
 * @param setting the setting to modify
 * @param value the value to set it to
 */
export const set = async <T extends TypeName>(setting: T, value: ObjectType<T>) => {
	// Make sure the setting can exist
	if (!(setting in DefaultValues)) throw Error(`Unknown setting: ${setting}`);

	// Create or modify the value
	await prisma.settings.upsert({
		create: {
			setting,
			value: value.toString()
		},
		update: {
			value: value.toString()
		},
		where: { setting }
	});
};
```


## Further Improvements

- **Caching**: Some settings are accessed frequently, and could be cached in-memory to reduce the number of database calls.